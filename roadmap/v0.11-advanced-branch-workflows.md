# v0.11: Advanced Branch Workflows

**Theme**: Time-travel, replay, and sandboxing — branches become a debugging and safety tool.

Fork/diff/merge shipped in v0.5. v0.11 adds the derivative capabilities that make branches powerful for auditing, debugging, and safe execution of untrusted agents.

---

## Time-Travel Queries

Read any primitive as of a timestamp or version. Turns the WAL from an implementation detail into a product feature.

- Works across KV, State, Event, JSON, and Vector
- Exposes read-only historical views
- Enables "why did this change?" debugging
- API: `db.at(timestamp).kv_get("key")`
- Builds on existing WAL + snapshot infrastructure
- Requires WAL indexing by timestamp or commit ID

### Implementation approach

The WAL already records every mutation with timestamps. Time-travel queries reconstruct state by:
1. Finding the nearest snapshot before the target timestamp
2. Replaying WAL entries up to the target timestamp
3. Returning a read-only view of the reconstructed state

For frequent access patterns, materialized snapshots at named points reduce reconstruction cost.

## Branch Replay

Treat a branch as a replayable session. Reconstruct the database state at any commit point, replay tool calls and state changes in order, export replay bundles for CI and reproducible bug reports.

- Deterministic reconstruction from WAL entries
- Step-through mode: advance one operation at a time
- Export replay bundles: self-contained archive with WAL segments + snapshots
- API: `db.replay_branch("branch", ReplayOptions)`

### Use cases

- **Debugging**: Replay an agent session to see exactly what happened, step by step
- **CI**: Import a replay bundle and verify that replaying produces the same final state
- **Auditing**: Prove that an agent's actions were deterministic and reproducible

## Memory Fences (Branch Sandboxing)

Constrain what a branch can read or write. Enables safe execution of untrusted or experimental agents.

- Allowlist/denylist by KV prefix, primitive, or vector collection
- Read-only fences for sensitive data, write-only fences for logging sinks
- Scoped merges: limit what a sandboxed branch can push back
- API: `db.sandbox_branch("branch", SandboxPolicy)`
- Extends `strata-security` crate with branch-level policy enforcement

### Built-in policy templates

| Template | Description |
|----------|-------------|
| `read-only-memory` | Branch can read all data but write nothing |
| `write-only-logging` | Branch can only append events and write to specific KV prefixes |
| `pii-safe` | Branch cannot access keys matching PII patterns; merge requires review |

### Enforcement

Policy violations are checked at command dispatch time via `PolicyGuard` (same pattern as `AccessMode`). Violations return structured `AccessDenied` errors.

---

## Key files

| Area | Files |
|------|-------|
| Time-travel | `crates/durability/src/wal/`, `crates/durability/src/disk_snapshot/` |
| Replay | `crates/engine/src/recovery/replay.rs` |
| Sandboxing | `crates/security/src/` |

## Dependencies

- v0.5 (fork/diff/merge — replay and sandboxing build on these)

## Open questions

- Do we expose a unified commit ID across primitives for time-travel?
- How do we index time for vector entries efficiently?
