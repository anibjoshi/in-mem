# v0.4: Vector Enhancements

**Theme**: Vector search at scale.

**Status**: Implemented (2026-02-03)

v0.1 shipped brute-force vector search, which is correct but O(n) per query. v0.4 adds approximate nearest neighbor indexing, advanced metadata filtering, batch operations, collection statistics, and a reserved internal namespace for the intelligence layer.

## Implemented Features

### HNSW Index Backend

Added Hierarchical Navigable Small World graph indexing for sub-linear vector search, built from scratch and verified against the Malkov & Yashunin paper (arXiv:1603.09320).

- `HnswBackend` implements `VectorIndexBackend` trait in `crates/engine/src/primitives/vector/hnsw.rs`
- `IndexBackendFactory::Hnsw(HnswConfig)` variant for per-collection backend selection
- Configurable parameters: M (16), ef_construction (200), ef_search (50)
- Deterministic: seeded PRNG (SplitMix64), BTreeMap nodes, BTreeSet neighbors
- Full snapshot serialization/deserialization of graph state
- `rebuild_graph()` for post-recovery reconstruction
- 17 unit tests including multi-query recall validation (>= 0.95 average)

### Advanced Metadata Filters

Extended metadata filtering beyond simple equality to 8 operators.

- `FilterCondition` and `FilterOp` types in `crates/core/src/primitives/vector.rs`
- Operators: Eq, Ne, Gt, Gte, Lt, Lte, In, Contains
- Full executor bridge support in `bridge.rs`
- Builder methods on `MetadataFilter`: `.ne()`, `.gt()`, `.gte()`, `.lt()`, `.lte()`, `.in_values()`, `.contains()`

### Batch Vector Upsert

Insert/update multiple vectors in a single atomic operation.

- `VectorBatchUpsert` command in executor
- `vector_batch_upsert()` API method
- `batch_insert()` engine method with single write lock
- Validates all entries before committing (no partial writes)

### Collection Statistics

Per-collection metrics exposed through the API.

- `VectorCollectionStats` command
- `vector_collection_stats()` API method
- `CollectionInfo` now includes `index_type` ("brute_force" or "hnsw") and `memory_bytes`
- Backed by `index_type_name()` and `memory_usage()` on `VectorIndexBackend` trait

### Reserved Internal Vector Namespace

`_system_*` collections for the intelligence layer.

- `validate_system_collection_name()` in `collection.rs`
- `create_system_collection()`, `system_insert()`, `system_search()` internal methods in `store.rs`
- `vector_list_collections` filters out `_`-prefixed collections from user results

### Shared Distance Functions

Extracted distance computation into a shared module.

- `distance.rs` with `compute_similarity()`, `cosine_similarity()`, `euclidean_similarity()`, `dot_product()`, `l2_norm()`, `euclidean_distance()`
- Both BruteForceBackend and HnswBackend import from this shared module

## Deferred Features

### F16 Half-Precision Storage

Deferred as premature optimization. `StorageDtype` reserves byte value `1` for F16.

### Int8 Scalar Quantization

Deferred as premature optimization. `StorageDtype` reserves byte value `2` for Int8.

## Context

Vector search is central to AI agent workloads (RAG, memory retrieval, similarity matching). Brute-force works for <10K vectors but real applications often need 100K+. The HNSW index backend unlocks these scales with ~95%+ recall at O(log n) search complexity.

## Dependencies

None â€” builds on v0.1 vector infrastructure.
